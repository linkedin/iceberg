/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.iceberg.hive.legacy;

import java.util.List;
import org.apache.hadoop.hive.serde2.typeinfo.ListTypeInfo;
import org.apache.hadoop.hive.serde2.typeinfo.MapTypeInfo;
import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;
import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;
import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
import org.apache.iceberg.relocated.com.google.common.collect.Lists;

/**
 * A Hive {@link TypeInfo} visitor with an accompanying partner schema
 *
 * This visitor traverses the Hive {@link TypeInfo} tree contiguously accessing the schema tree for the partner schema
 * using {@link PartnerAccessor}. When visiting each type in the Hive tree, the implementation is also presented
 * with the corresponding type from the partner schema, or else a {@code null} if no match was found. Matching
 * behavior can be controlled by implementing the methods in {@link PartnerAccessor}
 *
 * @param <P> type of partner schema
 * @param <FP> type of the field representation in the partner schema
 * @param <R> type of the resultant schema generated by the visitor
 * @param <FR> type of the field representation in the resultant schema
 */
@SuppressWarnings("ClassTypeParameterName")
public abstract class HiveSchemaWithPartnerVisitor<P, FP, R, FR> {

  /**
   * Methods to access types in the partner schema corresponding to types in the Hive schema being traversed
   *
   * @param <P> type of partner schema
   * @param <FP> type of the field representation in the partner schema
   */
  public interface PartnerAccessor<P, FP> {

    FP fieldPartner(P partnerStruct, String fieldName);

    P fieldType(FP partnerField);

    P mapKeyPartner(P partnerMap);

    P mapValuePartner(P partnerMap);

    P listElementPartner(P partnerList);
  }

  @SuppressWarnings("MethodTypeParameterName")
  public static <P, FP, R, FR> R visit(TypeInfo typeInfo, P partner, HiveSchemaWithPartnerVisitor<P, FP, R, FR> visitor,
      PartnerAccessor<P, FP> accessors) {
    switch (typeInfo.getCategory()) {
      case STRUCT:
        StructTypeInfo structTypeInfo = (StructTypeInfo) typeInfo;
        List<String> names = structTypeInfo.getAllStructFieldNames();
        List<FR> results = Lists.newArrayListWithExpectedSize(names.size());
        for (String name : names) {
          TypeInfo fieldTypeInfo = structTypeInfo.getStructFieldTypeInfo(name);
          FP fieldPartner = partner != null ? accessors.fieldPartner(partner, name) : null;
          P fieldPartnerType = fieldPartner != null ? accessors.fieldType(fieldPartner) : null;
          R result = visit(fieldTypeInfo, fieldPartnerType, visitor, accessors);
          results.add(visitor.field(name, fieldTypeInfo, fieldPartner, result));
        }
        return visitor.struct(structTypeInfo, partner, results);

      case LIST:
        ListTypeInfo listTypeInfo = (ListTypeInfo) typeInfo;
        TypeInfo elementTypeInfo = listTypeInfo.getListElementTypeInfo();
        P elementPartner = partner != null ? accessors.listElementPartner(partner) : null;
        R elementResult = visit(elementTypeInfo, elementPartner, visitor, accessors);
        return visitor.list(listTypeInfo, partner, elementResult);

      case MAP:
        MapTypeInfo mapTypeInfo = (MapTypeInfo) typeInfo;
        P keyPartner = partner != null ? accessors.mapKeyPartner(partner) : null;
        R keyResult = visit(mapTypeInfo.getMapKeyTypeInfo(), keyPartner, visitor, accessors);
        P valuePartner = partner != null ? accessors.mapValuePartner(partner) : null;
        R valueResult = visit(mapTypeInfo.getMapValueTypeInfo(), valuePartner, visitor, accessors);
        return visitor.map(mapTypeInfo, partner, keyResult, valueResult);

      case PRIMITIVE:
        return visitor.primitive((PrimitiveTypeInfo) typeInfo, partner);

      case UNION:
        throw new UnsupportedOperationException("Union data type not supported: " + typeInfo);

      default:
        throw new UnsupportedOperationException(typeInfo + " not supported");
    }
  }

  public R struct(StructTypeInfo struct, P partner, List<FR> fieldResults) {
    return null;
  }

  public FR field(String name, TypeInfo field, FP partner, R fieldResult) {
    return null;
  }

  public R list(ListTypeInfo list, P partner, R elementResult) {
    return null;
  }

  public R map(MapTypeInfo map, P partner, R keyResult, R valueResult) {
    return null;
  }

  public R primitive(PrimitiveTypeInfo primitive, P partner) {
    return null;
  }
}
